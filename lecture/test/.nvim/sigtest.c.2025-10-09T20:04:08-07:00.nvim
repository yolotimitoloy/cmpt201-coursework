#include "msgs.h"
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>
#define MAX_INPUT 1024
#define MAX_ARGS 100

// Ignore Ctrl+C in shell
void sigint_handler(int sig) {
  const char *msg = FORMAT_MSG("help", HELP_HELP_MSG);
  write(STDOUT_FILENO, msg, strlen(msg));
  const char *msg2 = FORMAT_MSG("cd", CD_HELP_MSG);
  write(STDOUT_FILENO, msg2, strlen(msg2));
  const char *msg3 = FORMAT_MSG("exit", EXIT_HELP_MSG);
  write(STDOUT_FILENO, msg3, strlen(msg3));
  const char *msg4 = FORMAT_MSG("pwd", PWD_HELP_MSG);
  write(STDOUT_FILENO, msg4, strlen(msg4));
  const char *msg5 = FORMAT_MSG("history", HISTORY_HELP_MSG);
  write(STDOUT_FILENO, msg5, strlen(msg5));
}

// Function to reap all terminated background processes
void reap_background() {
  int status;
  pid_t pid;
  // Loop to clean up all zombie children
  while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
    char buf[64];
    int len = snprintf(buf, sizeof(buf), "[Reaped background PID %d]\n", pid);
    write(STDOUT_FILENO, buf, len);
  }
}

int main() {
  char input[MAX_INPUT];
  char *args[MAX_ARGS];
  pid_t pid;
  int status;

  // Handle SIGINT
  signal(SIGINT, sigint_handler);

  while (1) {
    // Reap any background processes first
    reap_background();

    // Print prompt
    const char *prompt = "Shell> ";
    write(STDOUT_FILENO, prompt, strlen(prompt));

    // Read input
    int n = read(STDIN_FILENO, input, MAX_INPUT - 1);
    if (n <= 0)
      break; // EOF or error
    input[n] = '\0';

    // Remove trailing newline
    if (input[n - 1] == '\n')
      input[n - 1] = '\0';

    // Skip empty input
    if (strlen(input) == 0)
      continue;

    // Tokenize input
    int i = 0;
    char *token = strtok(input, " ");
    while (token != NULL && i < MAX_ARGS - 1) {
      args[i++] = token;
      token = strtok(NULL, " ");
    }
    args[i] = NULL;

    // Check for background &
    int background = 0;
    if (i > 0 && strcmp(args[i - 1], "&") == 0) {
      background = 1;
      args[i - 1] = NULL;
    }

    // Fork child
    pid = fork();
    if (pid < 0) {
      const char *err = "fork failed\n";
      write(STDOUT_FILENO, err, strlen(err));
      continue;
    } else if (pid == 0) {
      // Child: restore default Ctrl+C behavior
      signal(SIGINT, SIG_DFL);
      if (execvp(args[0], args) < 0) {
        const char *err = "exec failed\n";
        write(STDOUT_FILENO, err, strlen(err));
        exit(1);
      }
    } else {
      if (!background) {
        waitpid(pid, &status, 0); // Foreground process
      } else {
        char buf[64];
        int len = snprintf(buf, sizeof(buf), "[Background PID %d]\n", pid);
        write(STDOUT_FILENO, buf, len);
      }
    }
  }

  const char *exit_msg = "\nExiting shell...\n";
  write(STDOUT_FILENO, exit_msg, strlen(exit_msg));
  return 0;
}
