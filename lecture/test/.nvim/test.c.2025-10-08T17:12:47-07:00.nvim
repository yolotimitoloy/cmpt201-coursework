#define _GNU_SOURCE
#include "msgs.h"
#include <ctype.h>
#include <limits.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

bool numOnly(char *input) {
  for (int i = 1; input[i] != '\0'; i++) {
    if (!isdigit(input[1])) {
      return false;
    }
  }
  return true;
}

void phrase(char *input, char **args) {
  for (int x = 0; x < 8; x++) {
    args[x] = NULL;
  }
  int i = 0;
  char *token = NULL;
  char *ptr = NULL;
  while ((token = strtok_r(input, " \t\n\r", &ptr))) {
    args[i] = token;
    i++;
    input = NULL;
  }
  args[i] = NULL;
}
void printArgs(char **args) {
  for (int i = 0; args[i] != NULL; i++) {
    write(STDOUT_FILENO, args[i], strlen(args[i]));
    write(STDOUT_FILENO, "\n", 1);
    args[i] = NULL;
  }
}
char *input_hist[10];
int hist = 0;
int count = 0;
void dequeue() {
  free(input_hist[0]);
  for (int i = 1; i < hist; i++) {
    input_hist[i - 1] = input_hist[i];
  }
  hist--;
}

void enqueue(char *input) {
  if (hist > 9) {
    dequeue();
  }
  input_hist[hist] = strdup(input);
  hist++;
  count++;
}

char *get_hist(int num) {
  if (num == 0 && count >= 1) {
    return input_hist[0];
  } else if (num == 0) {
    return NULL;
  } else if (num > count || num < count - hist) {
    return NULL;
  } else if (count < 10) {
    return input_hist[num];
  } else {
    // debugging
    //    write(STDOUT_FILENO, input_hist[count - num], strlen(input_hist[count
    //    - num]));
    return input_hist[num - count + hist];
  }
}

char *get_Last() { return input_hist[hist - 1]; }

void print_hist() {
  for (int i = hist - 1; i >= 0; i--) {
    char counter[10];
    int temp = count - hist + i + 1;
    int tempLen = sprintf(counter, "%d: ", temp);
    write(STDOUT_FILENO, counter, tempLen);
    write(STDOUT_FILENO, input_hist[i], strlen(input_hist[i]));
  }
}

int main() {
  char cwd_buffer[4096];
  char *args[16];
  char input[4096];

  while (true) {

    getcwd(cwd_buffer, sizeof(cwd_buffer));
    size_t length = strlen(cwd_buffer);
    write(STDOUT_FILENO, cwd_buffer, length);
    write(STDOUT_FILENO, "$ ", 2);
    ssize_t inputLenght = read(STDIN_FILENO, input, sizeof(input) - 1);
    input[inputLenght] = '\0';
    // check for !! history
    if (input[0] == '!') {
      if (input[1] == '!') {
        char *temp = get_Last();
        if (temp == NULL) {
          const char *msg = FORMAT_MSG("history", HISTORY_NO_LAST_MSG);
          write(STDOUT_FILENO, msg, strlen(msg));
          continue;
        }
        strncpy(input, temp, strlen(temp));
        input[strlen(temp) + 1] = '\0';
      } else {
        char intHist[4];
        strcpy(intHist, input + 1);
        int temp_Hist = atoi(intHist);
        char *temp = get_hist(temp_Hist);
        if (!numOnly(input)) {
          const char *msg = FORMAT_MSG("history", HISTORY_INVALID_MSG);
          write(STDOUT_FILENO, msg, strlen(msg));
          continue;
        } else if (temp == NULL && hist == 0) {
          const char *msg = FORMAT_MSG("history", HISTORY_NO_LAST_MSG);
          write(STDOUT_FILENO, msg, strlen(msg));
          continue;
        }
        strncpy(input, temp, strlen(temp));
        input[strlen(temp) + 1] = '\0';
      }
      // add number here
    }
    enqueue(input);

    phrase(input, args);
    if (strcmp(args[0], "history") == 0) {
      print_hist();
    }

    if (strcmp(args[0], "exit") == 0) {
      if (args[1] != NULL) {
        const char *msg = FORMAT_MSG("exit", TMA_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
        continue;
      }
      break;
    }

    if (strcmp(args[0], "cd") == 0) {
      if (args[2] != NULL) {
        const char *msg = FORMAT_MSG("cd", TMA_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
        continue;
      }
      char *path = args[1];
      if (path == NULL) {
        path = getenv("HOME");
      } else if (path[0]=='~'){
        chdir(getenv("HOME"));
        memmove(path, path+1, strlen(path));
      }
      chdir(path);
    }

    if (strcmp(args[0], "pwd") == 0) {
      if (args[1] != NULL) {
        const char *msg = FORMAT_MSG("pwd", TMA_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
        continue;
      }
      if (getcwd(cwd_buffer, sizeof(cwd_buffer)) == NULL) {
        const char *msg = FORMAT_MSG("pwd", GETCWD_ERROR_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
        continue;
      }
      getcwd(cwd_buffer, sizeof(cwd_buffer));
      size_t length = strlen(cwd_buffer);
      write(STDOUT_FILENO, cwd_buffer, length);
      write(STDOUT_FILENO, "\n", 1);
    }

    if (strcmp(args[0], "help") == 0) {
      if (args[2] != NULL) {
        const char *msg = FORMAT_MSG("help", TMA_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
        continue;
      }

      if (args[1] == NULL) {
        const char *msg = FORMAT_MSG("help", HELP_HELP_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
        const char *msg2 = FORMAT_MSG("cd", CD_HELP_MSG);
        write(STDOUT_FILENO, msg2, strlen(msg2));
        const char *msg3 = FORMAT_MSG("exit", EXIT_HELP_MSG);
        write(STDOUT_FILENO, msg3, strlen(msg3));
        const char *msg4 = FORMAT_MSG("pwd", PWD_HELP_MSG);
        write(STDOUT_FILENO, msg4, strlen(msg4));
        const char *msg5 = FORMAT_MSG("history", HISTORY_HELP_MSG);
        write(STDOUT_FILENO, msg5, strlen(msg5));
      } else if (strcmp(args[1], "help") == 0) {
        const char *msg = FORMAT_MSG("help", HELP_HELP_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
      } else if (strcmp(args[1], "cd") == 0) {
        const char *msg = FORMAT_MSG("cd", CD_HELP_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
      } else if (strcmp(args[1], "exit") == 0) {
        const char *msg = FORMAT_MSG("exit", EXIT_HELP_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
      } else if (strcmp(args[1], "pwd") == 0) {
        const char *msg = FORMAT_MSG("pwd", PWD_HELP_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
      } else if (strcmp(args[1], "history") == 0) {
        const char *msg = FORMAT_MSG("history", HISTORY_HELP_MSG);
        write(STDOUT_FILENO, msg, strlen(msg));
      } else {
        char msg[1024];
        int len =
            snprintf(msg, sizeof(msg), "%s: %s\n", args[1], EXTERN_HELP_MSG);
        write(STDOUT_FILENO, msg, len);
      }
      // free(cwd_buffer);
      // free(args);
      // free(input);
    }
  }
}
