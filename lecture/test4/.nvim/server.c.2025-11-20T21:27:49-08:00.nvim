#define _DEFAULT_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdatomic.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <netinet/in.h>

#define MAX_MSG_SIZE 1024
#define MAX_CLIENTS 100 
#define TYPE_REGULAR 0
#define TYPE_END_EXECUTION 1

// Status code returned by handle_message to trigger TPC Phase 2
#define STATUS_TPC_COMMIT -3

// --- Data Structures for Message Queue ---

typedef struct message_node {
    char buffer[MAX_MSG_SIZE]; 
    size_t len;
    struct message_node *next;
} message_node_t;

message_node_t *queue_head = NULL;
message_node_t *queue_tail = NULL;

// --- Data Structures for Clients ---

typedef struct {
    int fd;
    struct sockaddr_in addr;
    socklen_t addr_len;
    char buffer[MAX_MSG_SIZE]; // Dedicated read buffer for partial data
    ssize_t data_len;          // Current length of data in the buffer
} client_t;

client_t clients[MAX_CLIENTS];
int num_clients = 0;
int expected_clients = 0;
int finished_clients_count = 0; 

// --- Synchronization Primitives ---

pthread_mutex_t queue_lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t queue_cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t client_list_lock = PTHREAD_MUTEX_INITIALIZER;

_Atomic bool server_running = true; 

// --- Function Prototypes ---
void error(const char *msg);
void set_non_blocking(int fd);
void enqueue_message(const char *buffer, size_t len);
message_node_t *dequeue_message();
void *broadcast_worker(void *arg);
int handle_message(int sender_fd, client_t *client, char *out_buffer, size_t max_out_len, size_t *out_len);
void remove_client(int fd);


void error(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

void set_non_blocking(int fd) {
  int flags = fcntl(fd, F_GETFL, 0);
  if (flags == -1) {
    error("fcntl F_GETFL");
  }
  if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
    error("fcntl F_SETFL");
  }
}

// --- Queue Operations (Thread-Safe) ---

void enqueue_message(const char *buffer, size_t len) {
    // This function must ONLY be called when client_list_lock is NOT held.
    message_node_t *new_node = (message_node_t *)malloc(sizeof(message_node_t));
    if (!new_node) {
        perror("malloc failed for message node");
        return;
    }
    memcpy(new_node->buffer, buffer, len);
    new_node->len = len;
    new_node->next = NULL;

    pthread_mutex_lock(&queue_lock);
    if (queue_tail == NULL) {
        queue_head = new_node;
        queue_tail = new_node;
    } else {
        queue_tail->next = new_node;
        queue_tail = new_node;
    }
    
    pthread_cond_signal(&queue_cond);
    pthread_mutex_unlock(&queue_lock);
}

message_node_t *dequeue_message() {
    pthread_mutex_lock(&queue_lock);
    
    while (queue_head == NULL && atomic_load(&server_running)) {
        pthread_cond_wait(&queue_cond, &queue_lock);
    }
    
    if (queue_head == NULL) {
        pthread_mutex_unlock(&queue_lock);
        return NULL;
    }
    
    message_node_t *node = queue_head;
    queue_head = queue_head->next;
    if (queue_head == NULL) {
        queue_tail = NULL;
    }
    
    pthread_mutex_unlock(&queue_lock);
    return node;
}

// --- Client Management ---

void remove_client(int fd) {
    pthread_mutex_lock(&client_list_lock);
    for (int i = 0; i < num_clients; i++) {
        if (clients[i].fd == fd) {
            close(fd);
            
            // Fix: Decrement expected_clients if the client was still pending
            if (finished_clients_count < expected_clients) {
                expected_clients--;
                printf("FD %d: Unexpected disconnect. Adjusted expected clients to %d.\n", fd, expected_clients);
            }
            
            if (i < num_clients - 1) {
                clients[i] = clients[num_clients - 1];
            }
            num_clients--;
            printf("Client disconnected (FD %d). Current clients: %d\n", fd, num_clients);
            pthread_mutex_unlock(&client_list_lock);
            return;
        }
    }
    pthread_mutex_unlock(&client_list_lock);
}

// --- Worker Threads ---

void *broadcast_worker(void *arg) {
    message_node_t *node;

    while (atomic_load(&server_running)) {
        node = dequeue_message();
        
        if (node == NULL) {
            if (!atomic_load(&server_running)) break;
            continue;
        }

        // Worker thread lock order: queue_lock (inside dequeue) -> client_list_lock (here)
        pthread_mutex_lock(&client_list_lock); 
        
        if ((unsigned char)node->buffer[0] == TYPE_END_EXECUTION) {
            printf("Broadcast Worker: Sending Phase 2 commit to all clients.\n");
        }

        for (int i = 0; i < num_clients; i++) {
            if (write(clients[i].fd, node->buffer, node->len) == -1) {
                 // Non-blocking writes are ignored for this simple broadcast
            }
        }
        
        pthread_mutex_unlock(&client_list_lock);
        
        free(node);
    }
    printf("Broadcast Worker thread exiting.\n");
    return NULL;
}

/**
 * @brief Processes one full message from the client's internal buffer.
 * Fills out_buffer and returns its length, or STATUS_TPC_COMMIT if Phase 2 is triggered.
 * IMPORTANT: This must be called while client_list_lock is held.
 */
int handle_message(int sender_fd, client_t *client, char *out_buffer, size_t max_out_len, size_t *out_len) {
    
    *out_len = 0;
    size_t msg_len = 0;
    
    char *buffer = client->buffer;
    ssize_t len = client->data_len;

    if (len <= 0) {
        return 0; 
    }

    char *newline_pos = memchr(buffer, '\n', len);
    if (!newline_pos) {
        return 0; // Incomplete message
    }

    msg_len = newline_pos - buffer + 1; // Length including '\n'
    unsigned char type = (unsigned char)buffer[0]; 

    if (type == TYPE_REGULAR) {
        // --- Type 0: Regular Group Chat Message ---
        
        struct sockaddr_in sender_addr;
        socklen_t addr_len = sizeof(sender_addr);
        if (getpeername(sender_fd, (struct sockaddr*)&sender_addr, &addr_len) == -1) {
            perror("getpeername failed");
        }
        
        unsigned int ip_nbo = sender_addr.sin_addr.s_addr;
        unsigned short port_nbo = sender_addr.sin_port;
        
        // Broadcast message format: [Type 0 (1B) | IP (4B) | Port (2B) | Client Data | '\n']
        size_t needed_len = msg_len + 6; 
        
        if (needed_len > max_out_len || needed_len > MAX_MSG_SIZE) {
            fprintf(stderr, "Message too long to broadcast. Dropping.\n");
        } else {
            out_buffer[0] = TYPE_REGULAR;
            memcpy(out_buffer + 1, &ip_nbo, sizeof(ip_nbo));
            memcpy(out_buffer + 1 + sizeof(ip_nbo), &port_nbo, sizeof(port_nbo));
            memcpy(out_buffer + 7, buffer + 1, msg_len - 1);
            *out_len = needed_len; 
        }
        
    } else if (type == TYPE_END_EXECUTION) {
        // --- Type 1: Termination Signal (Phase 1) ---
        
        if (msg_len != 2) {
            fprintf(stderr, "Received incorrect Type 1 message format (len=%zu). Must be 2 bytes. Discarding.\n", msg_len);
        } else {
            finished_clients_count++;
            printf("--- T1 RECEIVED --- FD %d. Count: %d/%d\n", sender_fd, finished_clients_count, expected_clients);
            
            if (finished_clients_count == expected_clients) {
                // --- Phase 2: Signal Commit ---
                printf("All expected clients finished. Signalling Phase 2 commit.\n");
                
                // Signal Main thread to enqueue the commit message (outside the lock)
                // and then initiate full server shutdown.
                // We do NOT call enqueue_message here to avoid the deadlock.
                
                return STATUS_TPC_COMMIT;
            }
        }
    } else {
        fprintf(stderr, "Received unknown message type: %u. Discarding message.\n", type);
    }
    
    // Shift the remaining data in the client's buffer to the start
    if (len > msg_len) {
        memmove(buffer, buffer + msg_len, len - msg_len);
    }
    client->data_len = len - msg_len;
    
    return *out_len;
}

void cleanup_and_exit(int server_fd, pthread_t worker_tid) {
    
    printf("SERVER CLEANUP: Starting shutdown process...\n");
    
    // 1. Signal worker to exit
    if (worker_tid != 0) {
        atomic_store(&server_running, false); 
        pthread_cond_signal(&queue_cond); 
        pthread_join(worker_tid, NULL);
    }

    // 2. Close all client connections
    pthread_mutex_lock(&client_list_lock);
    for (int i = 0; i < num_clients; i++) {
        printf("Closing client FD %d\n", clients[i].fd);
        close(clients[i].fd);
    }
    pthread_mutex_unlock(&client_list_lock);

    // 3. Close listener socket
    if (server_fd != -1) {
        close(server_fd);
    }

    // 4. Clean up queue nodes
    message_node_t *current = queue_head;
    while (current != NULL) {
        message_node_t *next = current->next;
        free(current);
        current = next;
    }

    printf("Server shutting down gracefully.\n");
    exit(EXIT_SUCCESS);
}


int main(int argc, char *argv[]) {
    int listen_fd, new_fd;
    struct sockaddr_in serv_addr, cli_addr;
    socklen_t clilen;
    pthread_t worker_tid;
    
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <port number> <# of clients>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    int port = atoi(argv[1]);
    expected_clients = atoi(argv[2]);
    
    // ... (Socket Setup as before) ...
    listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd < 0) {
        error("ERROR opening socket");
    }
    
    int opt = 1;
    if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
        perror("setsockopt");
    }
    
    set_non_blocking(listen_fd); 

    memset((char *) &serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY; 
    serv_addr.sin_port = htons(port);
    
    if (bind(listen_fd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        error("ERROR on binding");
    }
    
    if (listen(listen_fd, 5) < 0) {
        error("ERROR on listen");
    }
    
    printf("Server listening on port %d, expecting %d clients...\n", port, expected_clients);

    if (pthread_create(&worker_tid, NULL, broadcast_worker, NULL) != 0) {
        error("ERROR creating broadcast worker thread");
    }

    // Temporary storage for message extracted under client_list_lock
    char temp_broadcast_buffer[MAX_MSG_SIZE];
    size_t temp_broadcast_len = 0;
    
    // Main I/O thread loop: Busy-Wait Non-Blocking
    while (atomic_load(&server_running)) {
        
        // 5. Check for new connections (Non-Blocking Accept)
        clilen = sizeof(cli_addr);
        new_fd = accept(listen_fd, (struct sockaddr *) &cli_addr, &clilen);
        
        if (new_fd > 0) {
            set_non_blocking(new_fd); 
            
            pthread_mutex_lock(&client_list_lock);
            if (num_clients < MAX_CLIENTS) {
                clients[num_clients].fd = new_fd;
                clients[num_clients].addr = cli_addr;
                clients[num_clients].addr_len = clilen;
                clients[num_clients].data_len = 0; 
                
                printf("New connection from %s:%d on FD %d. Clients: %d\n",
                       inet_ntoa(cli_addr.sin_addr), ntohs(cli_addr.sin_port),
                       new_fd, num_clients + 1);
                       
                num_clients++;
            } else {
                fprintf(stderr, "Connection rejected: Max clients reached.\n");
                close(new_fd);
            }
            pthread_mutex_unlock(&client_list_lock);
        } else if (new_fd < 0 && errno != EWOULDBLOCK && errno != EAGAIN) {
             perror("accept error");
        }
        
        // 6. Check for incoming data from existing clients (Non-Blocking Read)
        
        // Ensure temporary state is clear before the loop
        temp_broadcast_len = 0;

        pthread_mutex_lock(&client_list_lock);
        
        for (int i = num_clients - 1; i >= 0; i--) { 
            client_t *client = &clients[i];
            
            ssize_t bytes_read = read(client->fd, 
                                      client->buffer + client->data_len, 
                                      MAX_MSG_SIZE - client->data_len);
                                      
            if (bytes_read > 0) {
                client->data_len += bytes_read;

                int process_result = 0;
                size_t extracted_len = 0;
                
                while (client->data_len > 0) {
                    
                    extracted_len = 0;
                    process_result = handle_message(client->fd, client, 
                                                    temp_broadcast_buffer, 
                                                    MAX_MSG_SIZE, 
                                                    &extracted_len);
                    
                    if (process_result == 0) {
                        break; // Incomplete message or no message
                    } 
                    
                    if (process_result == STATUS_TPC_COMMIT) {
                        // TPC Phase 2 triggered. Break array loop and exit the server.
                        temp_broadcast_len = (size_t)STATUS_TPC_COMMIT;
                        goto exit_client_loop; 
                    }
                    
                    if (extracted_len > 0) {
                        // Regular message extracted. Break inner loop to enqueue message 
                        // OUTSIDE the client_list_lock.
                        temp_broadcast_len = extracted_len;
                        goto exit_client_loop; 
                    }
                }
            } else if (bytes_read == 0 || (bytes_read < 0 && errno != EWOULDBLOCK && errno != EAGAIN)) {
                // Client disconnected (read == 0) or non-recoverable error
                remove_client(client->fd); 
            }
        }
        
        exit_client_loop:; // Label for breaking out of the inner loop
        
        pthread_mutex_unlock(&client_list_lock); 
        
        // --- Enqueue messages OUTSIDE of client_list_lock (DEADLOCK FIX) ---
        if (temp_broadcast_len > 0 && temp_broadcast_len != (size_t)STATUS_TPC_COMMIT) {
            enqueue_message(temp_broadcast_buffer, temp_broadcast_len);
        } else if (temp_broadcast_len == (size_t)STATUS_TPC_COMMIT) {
            // TPC Phase 2: Commit message enqueue and exit
            char commit_msg[] = {TYPE_END_EXECUTION, '\n'};
            enqueue_message(commit_msg, sizeof(commit_msg));
            atomic_store(&server_running, false); // Explicit shutdown flag set
        }

        // Check if TPC Phase 2 was triggered and execute cleanup
        if (!atomic_load(&server_running)) {
            cleanup_and_exit(listen_fd, worker_tid);
        }
        
        // Prevent 100% CPU usage by yielding time
        usleep(100); 
    }

    cleanup_and_exit(listen_fd, worker_tid);
    return 0;
}
