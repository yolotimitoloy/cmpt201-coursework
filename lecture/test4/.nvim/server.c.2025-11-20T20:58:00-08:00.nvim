#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <errno.h>
#include <stdint.h>
#include <poll.h> // Using poll.h instead of select.h
#include <pthread.h>

#define MAX_MSG_SIZE 1024
#define MAX_CLIENTS 100 
#define TYPE_REGULAR 0
#define TYPE_END_EXECUTION 1

// --- Data Structures for Message Queue ---

typedef struct message_node {
    char buffer[MAX_MSG_SIZE]; 
    size_t len;
    struct message_node *next;
} message_node_t;

message_node_t *queue_head = NULL;
message_node_t *queue_tail = NULL;

// --- Data Structures for Clients ---

typedef struct {
    int fd;
    struct sockaddr_in addr;
    socklen_t addr_len;
    // We will use a separate array for pollfd structures managed by the main loop
} client_t;

client_t clients[MAX_CLIENTS];
int num_clients = 0;
int expected_clients = 0;
int finished_clients_count = 0; 

// --- Synchronization Primitives ---

pthread_mutex_t queue_lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t queue_cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t client_list_lock = PTHREAD_MUTEX_INITIALIZER;
volatile int server_running = 1;


// --- Function Prototypes ---
void error(const char *msg);
void enqueue_message(const char *buffer, size_t len);
message_node_t *dequeue_message();
void *broadcast_worker(void *arg);
int handle_message(int sender_fd, char *buffer, ssize_t len);
void remove_client(int fd);


/**
 * @brief Utility function to print error message and exit.
 */
void error(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

// --- Queue Operations (Thread-Safe) ---

/**
 * @brief Adds a message to the broadcast queue.
 */
void enqueue_message(const char *buffer, size_t len) {
    message_node_t *new_node = (message_node_t *)malloc(sizeof(message_node_t));
    if (!new_node) {
        perror("malloc failed for message node");
        return;
    }
    memcpy(new_node->buffer, buffer, len);
    new_node->len = len;
    new_node->next = NULL;

    pthread_mutex_lock(&queue_lock);
    if (queue_tail == NULL) {
        queue_head = new_node;
        queue_tail = new_node;
    } else {
        queue_tail->next = new_node;
        queue_tail = new_node;
    }
    
    // Signal the broadcast worker that a new message is ready
    pthread_cond_signal(&queue_cond);
    pthread_mutex_unlock(&queue_lock);
}

/**
 * @brief Retrieves a message from the broadcast queue.
 */
message_node_t *dequeue_message() {
    pthread_mutex_lock(&queue_lock);
    
    // Wait until queue is not empty or server is shutting down
    while (queue_head == NULL && server_running) {
        pthread_cond_wait(&queue_cond, &queue_lock);
    }
    
    if (queue_head == NULL) {
        pthread_mutex_unlock(&queue_lock);
        return NULL; // Shutdown signal received
    }
    
    message_node_t *node = queue_head;
    queue_head = queue_head->next;
    if (queue_head == NULL) {
        queue_tail = NULL;
    }
    
    pthread_mutex_unlock(&queue_lock);
    return node;
}

// --- Client Management ---

/**
 * @brief Removes a client from the tracking array. (Protected by client_list_lock)
 * @return The index that the removed client occupied, or -1 if not found.
 */
void remove_client(int fd) {
    pthread_mutex_lock(&client_list_lock);
    for (int i = 0; i < num_clients; i++) {
        if (clients[i].fd == fd) {
            close(fd);
            // Move last client into the freed slot and decrease count
            if (i < num_clients - 1) {
                clients[i] = clients[num_clients - 1];
            }
            num_clients--;
            printf("Client disconnected (FD %d). Current clients: %d\n", fd, num_clients);
            pthread_mutex_unlock(&client_list_lock);
            return;
        }
    }
    pthread_mutex_unlock(&client_list_lock);
}

/**
 * @brief Worker thread that dequeues messages and sends them to all clients.
 */
void *broadcast_worker(void *arg) {
    message_node_t *node;

    while (server_running) {
        node = dequeue_message();
        
        if (node == NULL) {
            if (!server_running) break;
            continue;
        }

        pthread_mutex_lock(&client_list_lock);
        
        if ((uint8_t)node->buffer[0] == TYPE_END_EXECUTION) {
            printf("Broadcast Worker: Sending Phase 2 commit to all clients.\n");
        }

        for (int i = 0; i < num_clients; i++) {
            // Use write() as requested
            if (write(clients[i].fd, node->buffer, node->len) == -1) {
                // Error on write, likely client disconnected. Main loop handles cleanup.
            }
        }
        
        pthread_mutex_unlock(&client_list_lock);
        
        free(node);
    }
    printf("Broadcast Worker thread exiting.\n");
    return NULL;
}

/**
 * @brief Reads a full message (up to '\n') from a socket, processes it, and enqueues the broadcast payload.
 * * NOTE: This function expects the caller (main I/O loop) to hold the client_list_lock 
 * before calling it, as it accesses/modifies shared state (finished_clients_count).
 * * @return >0 if message was processed, 0 if incomplete, -1 on error/disconnect, -2 on server shutdown.
 */
int handle_message(int sender_fd, char *buffer, ssize_t len) {
    if (len <= 0) {
        return -1;
    }

    int shutdown_triggered = 0; 
    size_t msg_len = 0;

    char *newline_pos = memchr(buffer, '\n', len);
    if (!newline_pos) {
        return 0; // Incomplete message
    }

    msg_len = newline_pos - buffer + 1; // Length including '\n'
    uint8_t type = (uint8_t)buffer[0];

    if (type == TYPE_REGULAR) {
        // --- Type 0: Regular Group Chat Message ---
        
        struct sockaddr_in sender_addr;
        socklen_t addr_len = sizeof(sender_addr);
        if (getpeername(sender_fd, (struct sockaddr*)&sender_addr, &addr_len) == -1) {
            perror("getpeername failed");
            // Proceed to shift buffer and return msg_len to discard bad message
        }
        
        uint32_t ip_nbo = sender_addr.sin_addr.s_addr;
        uint16_t port_nbo = sender_addr.sin_port;
        
        // Broadcast message format: [Type 0 (1B) | IP (4B) | Port (2B) | Client Data | '\n']
        char broadcast_buffer[MAX_MSG_SIZE];
        
        if (msg_len + 6 > MAX_MSG_SIZE) {
            fprintf(stderr, "Message too long to broadcast. Dropping.\n");
        } else {
            broadcast_buffer[0] = TYPE_REGULAR;
            memcpy(broadcast_buffer + 1, &ip_nbo, sizeof(ip_nbo));
            memcpy(broadcast_buffer + 1 + sizeof(ip_nbo), &port_nbo, sizeof(port_nbo));
            memcpy(broadcast_buffer + 7, buffer + 1, msg_len - 1);
            
            size_t broadcast_len = msg_len + 6; 
            
            enqueue_message(broadcast_buffer, broadcast_len);
        }
        
    } else if (type == TYPE_END_EXECUTION) {
        // --- Type 1: Termination Signal (Phase 1) ---
        
        if (msg_len != 2) {
            fprintf(stderr, "Received incorrect Type 1 message format (len=%zu). Must be 2 bytes. Discarding.\n", msg_len);
        } else {
            // client_list_lock is ALREADY HELD by the caller (main I/O thread)
            finished_clients_count++;
            printf("--- T1 RECEIVED --- FD %d. Count: %d/%d\n", sender_fd, finished_clients_count, expected_clients);
            
            if (finished_clients_count == expected_clients) {
                // --- Phase 2: Commit ---
                printf("All expected clients finished. Starting Two-Phase Commit (Phase 2).\n");
                
                // Construct and enqueue Type 1 message
                char commit_msg[] = {TYPE_END_EXECUTION, '\n'};
                enqueue_message(commit_msg, sizeof(commit_msg));
                
                // Set flag and signal worker 
                server_running = 0;
                shutdown_triggered = 1;
                pthread_cond_signal(&queue_cond); 
            }
        }
    } else {
        fprintf(stderr, "Received unknown message type: %u. Discarding message.\n", type);
    }
    
    printf("handle_message processed type %u, length %zu. Remaining data in buffer: %zu\n", type, msg_len, len - msg_len);
    
    // CRITICAL FIX: Shift the remaining data in the buffer (if any) to the start BEFORE returning status
    if (len > msg_len) {
        memmove(buffer, buffer + msg_len, len - msg_len);
    }
    
    if (shutdown_triggered) {
        return -2;
    }
    
    return msg_len;
}

void cleanup_and_exit(int server_fd, pthread_t worker_tid) {
    
    printf("SERVER CLEANUP: Starting shutdown process...\n");
    
    // 1. Wait for the broadcast worker to finish
    if (worker_tid != 0) {
        server_running = 0;
        pthread_cond_signal(&queue_cond); // Ensure worker wakes up and sees server_running=0
        pthread_join(worker_tid, NULL);
    }

    // 2. Close all client connections
    pthread_mutex_lock(&client_list_lock);
    for (int i = 0; i < num_clients; i++) {
        printf("Closing client FD %d\n", clients[i].fd);
        close(clients[i].fd);
    }
    pthread_mutex_unlock(&client_list_lock);

    // 3. Close listener socket
    if (server_fd != -1) {
        close(server_fd);
    }

    // 4. Clean up queue nodes
    message_node_t *current = queue_head;
    while (current != NULL) {
        message_node_t *next = current->next;
        free(current);
        current = next;
    }

    printf("Server shutting down gracefully.\n");
    exit(EXIT_SUCCESS);
}


int main(int argc, char *argv[]) {
    int listen_fd, new_fd;
    struct sockaddr_in serv_addr, cli_addr;
    socklen_t clilen;
    pthread_t worker_tid;
    
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <port number> <# of clients>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    int port = atoi(argv[1]);
    expected_clients = atoi(argv[2]);
    
    // 1. Create socket
    listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd < 0) {
        error("ERROR opening socket");
    }
    
    int opt = 1;
    if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
        perror("setsockopt");
    }

    // 2. Initialize and bind socket
    memset((char *) &serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY; 
    serv_addr.sin_port = htons(port);
    
    if (bind(listen_fd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        error("ERROR on binding");
    }
    
    // 3. Listen
    if (listen(listen_fd, 5) < 0) {
        error("ERROR on listen");
    }
    
    printf("Server listening on port %d, expecting %d clients...\n", port, expected_clients);

    // 4. Start the dedicated Broadcast Worker thread
    if (pthread_create(&worker_tid, NULL, broadcast_worker, NULL) != 0) {
        error("ERROR creating broadcast worker thread");
    }

    // Main I/O thread loop using poll()
    struct pollfd poll_fds[MAX_CLIENTS + 1]; // +1 for the listening socket
    poll_fds[0].fd = listen_fd;
    poll_fds[0].events = POLLIN;
    int nfds = 1; // Number of FDs currently managed (listener only initially)
    
    char client_buffers[MAX_CLIENTS][MAX_MSG_SIZE];
    ssize_t client_data_len[MAX_CLIENTS] = {0}; 
    
    // Helper array to map poll_fds index (1 to num_clients) back to clients array index (0 to num_clients - 1)
    int poll_to_client_index[MAX_CLIENTS]; 
    

    while (server_running) {
        // poll() blocks until activity or timeout (1 second)
        int activity = poll(poll_fds, nfds, 1000); 
        
        if (activity < 0) {
            if (errno == EINTR) continue;
            perror("poll error");
            break;
        }

        if (activity == 0) {
            continue;
        }
        
        // 5. Handle new connection attempts (always poll_fds[0])
        if (poll_fds[0].revents & POLLIN) {
            clilen = sizeof(cli_addr);
            new_fd = accept(listen_fd, (struct sockaddr *) &cli_addr, &clilen);
            
            if (new_fd < 0) {
                perror("accept error");
            } else {
                pthread_mutex_lock(&client_list_lock);
                if (num_clients < MAX_CLIENTS) {
                    
                    // Add to clients array
                    clients[num_clients].fd = new_fd;
                    clients[num_clients].addr = cli_addr;
                    clients[num_clients].addr_len = clilen;
                    
                    // Add to poll_fds array
                    poll_fds[nfds].fd = new_fd;
                    poll_fds[nfds].events = POLLIN;
                    
                    // Initialize client buffer and mapping
                    client_data_len[num_clients] = 0;
                    poll_to_client_index[num_clients] = num_clients; 
                    
                    printf("New connection from %s:%d on FD %d. Clients: %d\n",
                           inet_ntoa(cli_addr.sin_addr), ntohs(cli_addr.sin_port),
                           new_fd, num_clients + 1);
                           
                    num_clients++;
                    nfds++;
                } else {
                    fprintf(stderr, "Connection rejected: Max clients reached.\n");
                    close(new_fd);
                }
                pthread_mutex_unlock(&client_list_lock);
            }
            activity--;
        }
        
        // 6. Handle data from existing clients (poll_fds[1] onward)
        pthread_mutex_lock(&client_list_lock); 
        for (int i = 1; i < nfds && activity > 0; ) {
            
            if (poll_fds[i].revents & (POLLIN | POLLHUP | POLLERR)) {
                
                int client_fd = poll_fds[i].fd;
                // Since nfds is 1 + num_clients, client index is i - 1
                int client_idx = i - 1; 

                // Check for HUP/Error first
                if (poll_fds[i].revents & (POLLHUP | POLLERR)) {
                    printf("Client disconnected (FD %d).\n", client_fd);
                    
                    // Remove client from tracking arrays
                    remove_client(client_fd);
                    
                    // Shift the poll_fds array to fill the gap (fast removal)
                    poll_fds[i] = poll_fds[nfds - 1]; 
                    nfds--; // Decrease count
                    activity--;
                    
                    // DO NOT increment i, as the new element at i must be processed
                    continue; 
                }

                // Handle incoming data (POLLIN)
                ssize_t bytes_read = read(client_fd, 
                                          client_buffers[client_idx] + client_data_len[client_idx], 
                                          MAX_MSG_SIZE - client_data_len[client_idx]);
                                          
                if (bytes_read <= 0) {
                    // Disconnect or error (detected by read, not poll)
                    printf("Client disconnected (FD %d).\n", client_fd);
                    remove_client(client_fd);
                    
                    // Shift the poll_fds array to fill the gap
                    poll_fds[i] = poll_fds[nfds - 1]; 
                    nfds--; 
                    activity--;
                    continue; // DO NOT increment i
                }
                
                client_data_len[client_idx] += bytes_read;

                // Process all full messages that arrived in the buffer
                int process_result = 0;
                while ((process_result = handle_message(client_fd, client_buffers[client_idx], client_data_len[client_idx])) > 0) {
                    client_data_len[client_idx] -= process_result;
                }
                
                if (process_result == -2) {
                    // Server termination signal received (Phase 2 completed)
                    pthread_mutex_unlock(&client_list_lock); 
                    cleanup_and_exit(listen_fd, worker_tid);
                }
                
                activity--;
            }
            i++; // Move to the next descriptor
        }
        pthread_mutex_unlock(&client_list_lock); 
    }

    cleanup_and_exit(listen_fd, worker_tid);
    return 0;
}
