#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <errno.h>
#include <stdint.h>
// #include <sys/select.h> // REMOVED
#include <pthread.h>

#define MAX_MSG_SIZE 1024
#define MAX_CLIENTS 100 
#define TYPE_REGULAR 0
#define TYPE_END_EXECUTION 1

// --- Data Structures for Message Queue ---

typedef struct message_node {
    char buffer[MAX_MSG_SIZE]; // Fully constructed broadcast message
    size_t len;
    struct message_node *next;
} message_node_t;

message_node_t *queue_head = NULL;
message_node_t *queue_tail = NULL;

// --- Data Structures for Clients ---

typedef struct {
    int fd;
    pthread_t thread_id; // Added thread ID
    struct sockaddr_in addr;
    socklen_t addr_len;
} client_t;

client_t clients[MAX_CLIENTS];
int num_clients = 0;
int expected_clients = 0;
int finished_clients_count = 0; 

// --- Synchronization Primitives ---

pthread_mutex_t queue_lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t queue_cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t client_list_lock = PTHREAD_MUTEX_INITIALIZER;
volatile int server_running = 1;

// --- Function Prototypes ---
void error(const char *msg);
void enqueue_message(const char *buffer, size_t len);
message_node_t *dequeue_message();
void *broadcast_worker(void *arg);
void *client_handler_thread(void *arg);
int handle_message_core(int sender_fd, char *buffer, ssize_t len);
void remove_client(int fd);


/**
 * @brief Utility function to print error message and exit.
 */
void error(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

// --- Queue Operations (Thread-Safe) ---

void enqueue_message(const char *buffer, size_t len) {
    // ... (Implementation remains the same)
    message_node_t *new_node = (message_node_t *)malloc(sizeof(message_node_t));
    if (!new_node) {
        perror("malloc failed for message node");
        return;
    }
    memcpy(new_node->buffer, buffer, len);
    new_node->len = len;
    new_node->next = NULL;

    pthread_mutex_lock(&queue_lock);
    if (queue_tail == NULL) {
        queue_head = new_node;
        queue_tail = new_node;
    } else {
        queue_tail->next = new_node;
        queue_tail = new_node;
    }
    
    pthread_cond_signal(&queue_cond);
    pthread_mutex_unlock(&queue_lock);
}

message_node_t *dequeue_message() {
    // ... (Implementation remains the same)
    pthread_mutex_lock(&queue_lock);
    
    while (queue_head == NULL && server_running) {
        pthread_cond_wait(&queue_cond, &queue_lock);
    }
    
    if (queue_head == NULL) {
        pthread_mutex_unlock(&queue_lock);
        return NULL;
    }
    
    message_node_t *node = queue_head;
    queue_head = queue_head->next;
    if (queue_head == NULL) {
        queue_tail = NULL;
    }
    
    pthread_mutex_unlock(&queue_lock);
    return node;
}

// --- Client Management ---

/**
 * @brief Removes a client from the tracking array. (Protected by client_list_lock)
 */
void remove_client(int fd) {
    pthread_mutex_lock(&client_list_lock);
    for (int i = 0; i < num_clients; i++) {
        if (clients[i].fd == fd) {
            close(fd);
            // Move last client into the freed slot and decrease count
            if (i < num_clients - 1) {
                clients[i] = clients[num_clients - 1];
            }
            num_clients--;
            printf("Client disconnected (FD %d). Current clients: %d\n", fd, num_clients);
            pthread_mutex_unlock(&client_list_lock);
            return;
        }
    }
    pthread_mutex_unlock(&client_list_lock);
}

// --- Worker Threads ---

/**
 * @brief Broadcast Worker thread (unchanged)
 */
void *broadcast_worker(void *arg) {
    message_node_t *node;

    while (server_running) {
        node = dequeue_message();
        
        if (node == NULL) {
            if (!server_running) break;
            continue;
        }

        // --- Broadcast Message (Type 0 or Type 1) ---
        
        pthread_mutex_lock(&client_list_lock);
        
        if ((uint8_t)node->buffer[0] == TYPE_END_EXECUTION) {
            printf("Broadcast Worker: Sending Phase 2 commit to all clients.\n");
        }

        for (int i = 0; i < num_clients; i++) {
            if (write(clients[i].fd, node->buffer, node->len) == -1) {
                // In a multi-threaded model, handle write errors aggressively, as 
                // the handler thread might have already exited, but the FD is still 
                // in the list briefly.
                // We'll trust the handler thread to clean up the FD eventually.
            }
        }
        
        pthread_mutex_unlock(&client_list_lock);
        
        free(node);
    }
    printf("Broadcast Worker thread exiting.\n");
    return NULL;
}

/**
 * @brief Core message processing logic, now extracted and called from threads.
 * * NOTE: The caller (the handler thread) MUST hold client_list_lock before calling this
 * if a Type 1 message is received, as this modifies finished_clients_count.
 * * @return >0 if message was processed, 0 if incomplete, -1 on error/disconnect, -2 on server shutdown.
 */
int handle_message_core(int sender_fd, char *buffer, ssize_t len) {
    if (len <= 0) {
        return -1;
    }

    int shutdown_triggered = 0;
    size_t msg_len = 0;

    char *newline_pos = memchr(buffer, '\n', len);
    if (!newline_pos) {
        return 0; // Incomplete message
    }

    msg_len = newline_pos - buffer + 1;
    uint8_t type = (uint8_t)buffer[0];

    if (type == TYPE_REGULAR) {
        // --- Type 0: Regular Group Chat Message ---
        
        struct sockaddr_in sender_addr;
        socklen_t addr_len = sizeof(sender_addr);
        if (getpeername(sender_fd, (struct sockaddr*)&sender_addr, &addr_len) == -1) {
            perror("getpeername failed");
        }
        
        uint32_t ip_nbo = sender_addr.sin_addr.s_addr;
        uint16_t port_nbo = sender_addr.sin_port;
        
        char broadcast_buffer[MAX_MSG_SIZE];
        
        if (msg_len + 6 > MAX_MSG_SIZE) {
            fprintf(stderr, "Message too long to broadcast. Dropping.\n");
        } else {
            broadcast_buffer[0] = TYPE_REGULAR;
            memcpy(broadcast_buffer + 1, &ip_nbo, sizeof(ip_nbo));
            memcpy(broadcast_buffer + 1 + sizeof(ip_nbo), &port_nbo, sizeof(port_nbo));
            memcpy(broadcast_buffer + 7, buffer + 1, msg_len - 1);
            
            size_t broadcast_len = msg_len + 6; 
            
            enqueue_message(broadcast_buffer, broadcast_len);
        }
        
    } else if (type == TYPE_END_EXECUTION) {
        // --- Type 1: Termination Signal (Phase 1) ---
        
        if (msg_len != 2) {
            fprintf(stderr, "Received incorrect Type 1 message format (len=%zu). Must be 2 bytes. Discarding.\n", msg_len);
        } else {
            // LOCK MUST BE HELD BY CALLER (client_handler_thread)
            finished_clients_count++;
            printf("--- T1 RECEIVED --- FD %d. Count: %d/%d\n", sender_fd, finished_clients_count, expected_clients);
            
            if (finished_clients_count == expected_clients) {
                // --- Phase 2: Commit ---
                printf("All expected clients finished. Starting Two-Phase Commit (Phase 2).\n");
                
                char commit_msg[] = {TYPE_END_EXECUTION, '\n'};
                enqueue_message(commit_msg, sizeof(commit_msg));
                
                server_running = 0;
                shutdown_triggered = 1;
                pthread_cond_signal(&queue_cond); 
            }
        }
    } else {
        fprintf(stderr, "Received unknown message type: %u. Discarding message.\n", type);
    }
    
    printf("handle_message processed type %u, length %zu. Remaining data in buffer: %zu\n", type, msg_len, len - msg_len);
    
    if (len > msg_len) {
        memmove(buffer, buffer + msg_len, len - msg_len);
    }
    
    if (shutdown_triggered) {
        return -2;
    }
    
    return msg_len;
}

/**
 * @brief Dedicated thread to handle all I/O for a single client.
 */
void *client_handler_thread(void *arg) {
    int client_fd = *(int*)arg;
    free(arg); // Free the allocated FD container
    
    char buffer[MAX_MSG_SIZE];
    ssize_t data_len = 0;

    printf("Handler thread started for FD %d.\n", client_fd);

    while (server_running) {
        // Use a blocking read() for this dedicated thread
        ssize_t bytes_read = read(client_fd, buffer + data_len, MAX_MSG_SIZE - data_len);

        if (bytes_read <= 0) {
            if (bytes_read == 0) {
                printf("Handler FD %d: Client disconnected.\n", client_fd);
            } else {
                if (errno != EINTR && server_running) {
                    perror("Handler: read error");
                }
            }
            break; // Exit loop on disconnect or error
        }
        
        data_len += bytes_read;

        // Process all full messages in the buffer
        int process_result = 0;
        
        // We must lock the client list before processing a Type 1 message.
        // Since we don't know the type until we process it, we must lock defensively.
        pthread_mutex_lock(&client_list_lock);
        
        while ((process_result = handle_message_core(client_fd, buffer, data_len)) > 0) {
            data_len -= process_result;
        }

        pthread_mutex_unlock(&client_list_lock); // Release lock

        if (process_result == -2) {
            printf("Handler FD %d: Server-wide shutdown initiated.\n", client_fd);
            // Wait for main thread to handle cleanup and termination
            break; 
        }
    }
    
    // Clean up the client list entry when the thread exits
    remove_client(client_fd);
    printf("Handler thread for FD %d exiting.\n", client_fd);
    return NULL;
}

void cleanup_and_exit(int server_fd, pthread_t worker_tid) {
    
    printf("SERVER CLEANUP: Starting shutdown process...\n");
    
    // 1. Terminate all client handler threads gracefully
    // Note: We rely on the server_running flag to terminate blocking reads.
    pthread_mutex_lock(&client_list_lock);
    for (int i = 0; i < num_clients; i++) {
        printf("Canceling client handler thread for FD %d\n", clients[i].fd);
        // Using cancel is less clean, relying on the thread's read() to fail/break the loop.
        // We will join them to ensure they exit.
        pthread_cancel(clients[i].thread_id); 
        pthread_join(clients[i].thread_id, NULL);
        close(clients[i].fd);
    }
    pthread_mutex_unlock(&client_list_lock);
    
    // 2. Wait for the broadcast worker to finish
    if (worker_tid != 0) {
        pthread_join(worker_tid, NULL);
    }

    // 3. Close listener socket
    if (server_fd != -1) {
        close(server_fd);
    }

    // 4. Clean up queue nodes
    message_node_t *current = queue_head;
    while (current != NULL) {
        message_node_t *next = current->next;
        free(current);
        current = next;
    }

    printf("Server shutting down gracefully.\n");
    exit(EXIT_SUCCESS);
}


int main(int argc, char *argv[]) {
    int listen_fd;
    struct sockaddr_in serv_addr, cli_addr;
    socklen_t clilen;
    pthread_t worker_tid;
    
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <port number> <# of clients>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    int port = atoi(argv[1]);
    expected_clients = atoi(argv[2]);
    
    // 1. Create socket
    listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd < 0) {
        error("ERROR opening socket");
    }
    
    int opt = 1;
    if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
        perror("setsockopt");
    }

    // 2. Initialize and bind socket
    memset((char *) &serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY; 
    serv_addr.sin_port = htons(port);
    
    if (bind(listen_fd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        error("ERROR on binding");
    }
    
    // 3. Listen
    if (listen(listen_fd, 5) < 0) {
        error("ERROR on listen");
    }
    
    printf("Server listening on port %d, expecting %d clients...\n", port, expected_clients);

    // 4. Start the dedicated Broadcast Worker thread
    if (pthread_create(&worker_tid, NULL, broadcast_worker, NULL) != 0) {
        error("ERROR creating broadcast worker thread");
    }

    // Main I/O thread loop: now only handles accepting connections (blocking accept)
    while (server_running) {
        // Using accept() in a loop without select/poll means the thread blocks here
        // until a new connection arrives.
        int new_fd;
        
        clilen = sizeof(cli_addr);
        new_fd = accept(listen_fd, (struct sockaddr *) &cli_addr, &clilen);
        
        if (new_fd < 0) {
            if (errno == EINTR) continue; // Restart on interrupt
            if (!server_running) break; // Exit if interrupted due to shutdown
            perror("accept error");
            break;
        }

        // 5. Handle new connection attempts
        pthread_mutex_lock(&client_list_lock);
        if (num_clients < MAX_CLIENTS) {
            // Allocate memory for the FD to pass to the new thread
            int *client_fd_arg = (int *)malloc(sizeof(int));
            if (!client_fd_arg) {
                fprintf(stderr, "Failed to allocate memory for FD argument.\n");
                close(new_fd);
                pthread_mutex_unlock(&client_list_lock);
                continue;
            }
            *client_fd_arg = new_fd;

            pthread_t handler_tid;
            // Spawn a dedicated handler thread
            if (pthread_create(&handler_tid, NULL, client_handler_thread, client_fd_arg) != 0) {
                error("ERROR creating client handler thread");
                free(client_fd_arg);
                close(new_fd);
            } else {
                // Store the client info and thread ID
                clients[num_clients].fd = new_fd;
                clients[num_clients].thread_id = handler_tid;
                clients[num_clients].addr = cli_addr;
                clients[num_clients].addr_len = clilen;
                
                printf("New connection from %s:%d on FD %d. Clients: %d\n",
                       inet_ntoa(cli_addr.sin_addr), ntohs(cli_addr.sin_port),
                       new_fd, num_clients + 1);
                       
                num_clients++;
            }
        } else {
            fprintf(stderr, "Connection rejected: Max clients reached.\n");
            close(new_fd);
        }
        pthread_mutex_unlock(&client_list_lock);
    }

    // Exit procedure
    cleanup_and_exit(listen_fd, worker_tid);
    return 0;
}
