#define _DEFAULT_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>
#include <fcntl.h> // Required for fcntl()

// --- Global Variables ---
#define PORT 8080
#define MAX_CLIENTS 30

// Shared state flag for controlled shutdown, protected by a mutex
volatile int server_running = 1;
pthread_mutex_t running_mutex = PTHREAD_MUTEX_INITIALIZER;

// Global listener file descriptor (used for the non-blocking accept)
int listen_fd_global = -1;

// --- Utility Functions ---

/**
 * @brief Handles communication with an individual client.
 * @param socket_desc_ptr A pointer to the client socket file descriptor.
 * @return void* Always NULL upon thread exit.
 */
void *client_handler(void *socket_desc_ptr) {
    int client_socket = *(int *)socket_desc_ptr;
    free(socket_desc_ptr); // Free the memory allocated in the main thread
    
    char buffer[1024] = {0};
    ssize_t valread;
    
    printf("[Client %d] Handler thread started.\n", client_socket);

    // Read the client message
    if ((valread = read(client_socket, buffer, 1024)) > 0) {
        // Null-terminate the string
        buffer[valread] = '\0';
        printf("[Client %d] Received: %s\n", client_socket, buffer);

        // Simple response
        const char *message = "Hello from the server! Message received.";
        send(client_socket, message, strlen(message), 0);
        printf("[Client %d] Response sent.\n", client_socket);
    } else if (valread == 0) {
        printf("[Client %d] Client disconnected gracefully.\n", client_socket);
    } else {
        perror("[Client Handler] read failed");
    }

    // Close the socket and exit the thread
    close(client_socket);
    printf("[Client %d] Handler thread finished.\n", client_socket);
    return NULL;
}

/**
 * @brief Thread dedicated to receiving the "shutdown" command.
 * @param arg Unused argument.
 * @return void* Always NULL upon thread exit.
 */
void *server_control_thread(void *arg) {
    char input_buffer[64];
    
    printf("\n--- Server Control Thread Activated ---\n");
    printf("Enter 'shutdown' to stop the server gracefully.\n");

    // Loop until the shutdown command is received
    while (1) {
        if (fgets(input_buffer, sizeof(input_buffer), stdin) != NULL) {
            // Remove newline character
            input_buffer[strcspn(input_buffer, "\n")] = 0; 
            
            if (strcmp(input_buffer, "shutdown") == 0) {
                printf("\n[Control] Shutdown command received. Initiating graceful stop...\n");
                
                // Set the global running flag to 0 safely
                pthread_mutex_lock(&running_mutex);
                server_running = 0;
                pthread_mutex_unlock(&running_mutex);

                // No need to close the listen socket here!
                // The main thread is non-blocking and will notice the flag change.
                break; // Exit the control loop
            } else {
                printf("[Control] Unknown command: %s. Type 'shutdown'.\n", input_buffer);
            }
        } else {
            // Handle EOF/error on stdin
            break;
        }
    }
    return NULL;
}


// --- Main Program ---
int main(int argc, char const *argv[]) {
    int server_fd, addrlen = sizeof(struct sockaddr_in);
    struct sockaddr_in address;

    // 1. Create socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }
    listen_fd_global = server_fd; // Store globally for closure

    // Set socket options to reuse address and port (helpful for debugging)
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt failed");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // 2. Bind the socket
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("Bind failed");
        exit(EXIT_FAILURE);
    }

    // 3. Start listening for connections
    if (listen(server_fd, MAX_CLIENTS) < 0) {
        perror("Listen failed");
        exit(EXIT_FAILURE);
    }

    // *******************************************************************
    // 4. Set the listening socket to NON-BLOCKING mode
    // This is the core change to enable polling/timeout logic similar to select()
    // *******************************************************************
    int flags = fcntl(server_fd, F_GETFL, 0);
    if (flags == -1) {
        perror("F_GETFL failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    if (fcntl(server_fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("F_SETFL O_NONBLOCK failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    printf("Listening socket set to non-blocking mode.\n");
    
    // Create the control thread
    pthread_t control_tid;
    if (pthread_create(&control_tid, NULL, server_control_thread, NULL) != 0) {
        perror("Failed to create control thread");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    // Main server loop (now a polling loop)
    while (server_running) {
        // Check the running flag first before attempting I/O
        if (!server_running) break; 
        
        // Try to accept a new connection (this call will not block indefinitely)
        int new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);

        if (new_socket > 0) {
            // Success: A client connected
            printf("[Main] New connection accepted on socket %d\n", new_socket);

            // Allocate memory for the socket descriptor to pass to the thread
            int *new_sock = (int *)malloc(sizeof(int));
            if (new_sock == NULL) {
                perror("[Main] Failed to allocate memory for client socket");
                close(new_socket);
                continue; 
            }
            *new_sock = new_socket;

            // Create a new thread for the client
            pthread_t client_tid;
            if (pthread_create(&client_tid, NULL, client_handler, (void *)new_sock) < 0) {
                perror("[Main] Could not create client thread");
                free(new_sock); // Free memory on failure
                close(new_socket);
            }
            // Detach the thread so its resources are automatically cleaned up
            pthread_detach(client_tid);
            
        } else if (new_socket < 0) {
            // Check for non-blocking errors (EAGAIN/EWOULDBLOCK)
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // No incoming connections right now. This is expected in non-blocking mode.
                // We pause briefly before checking the flag and trying again.
                usleep(100000); // Sleep for 100ms (100,000 microseconds)
            } else {
                // A real error occurred (e.g., connection reset, etc.)
                // If it's a server closing error, we check the flag.
                if (server_running) {
                    perror("[Main] Accept failed unexpectedly");
                }
                // If server_running is false, the error is likely due to server shutdown, and we break.
                break; 
            }
        }
    }

    // --- Graceful Shutdown Sequence ---
    printf("\n[Main] Exiting main loop. Shutting down server...\n");

    // Close the listening socket
    if (listen_fd_global != -1) {
        close(listen_fd_global);
        printf("[Main] Listener socket closed.\n");
    }

    // Wait for the control thread to finish (it should be waiting for 'shutdown' to be typed)
    pthread_join(control_tid, NULL);
    printf("[Main] Control thread joined.\n");

    // Note: We do NOT wait for client threads; they clean up and exit on their own (detached).
    
    printf("Server shutdown complete. Goodbye!\n");
    return 0;
}
